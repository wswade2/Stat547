---
title: "Homework 6"
output: 
  html_document: 
    keep_md: yes
---

Welcome to homework 6! For this homework, I've been asked to choose from a list of 6 tasks. I have chosen to do tasks 2 and 6. I'll first be creating my own function and will finish up by exploring nested dataframes.

Prompt:
"Write a couple of experimental functions exploring some functionality that is useful to you in real life and that might form the basis of your personal package."

Because I work in the social sciences, I find myself doing a LOT of copy/pasting ggplot2 code for histograms and barplots. These figures constitute 75% of my "exploratory data analysis," so it would be very useful if I could automate this process. My goal then is to create a function that will produce histograms of every variable in any dataframe that I read into R. Afterwards, I would like to find a way to automate the generation of 2X2 barplots to show interation effects between two or more independent variables and a single dependent variable. Perhaps later this can serve as the basis for an R package of my creation. 

Some people might suggest plotting several histograms at once (in a single panel) using various R packages, but I find this clunky. I like being able to look at each variable in isolation. 

First, I'll read in some data. This is a dataset called EWB light that was collected by personality psychologists.

```{r}
ewb <- read.table("C:/Users/Wade/Dropbox/Psych 546E 2016/Datasets/ewblight.txt", header=TRUE)
head(ewb)
```

```{r warning = FALSE}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(psych))
# Psych is an R package developed for psychologists. It's mostly used to print tables of 
# summary statistics that are commonly used in psychology.
```

For loops follow the following syntax:

for (var in seq) {
  expr
}

That is to say: For each variable in this sequence (or each element in this set), execute this expression.

You can also insert a break statement if you don't want the for loop to be performed on the entire sequence. Ex:

for (var in seq) {
  if (nchar(var) > 10) {
  break
  }
  expr(var)
}
 
You can use "next" instead of break if you want to skip a variable. 

```{r}
names <- names(ewb)
names(ewb)
classes<-sapply(ewb, class)
```


```{r}
for(name in names) {
 hist(ewb[,name])
}
```

This code appears to work, but the titles are all messed up. I have to use a for loop with a different syntax to put the column names on the graphs.

```{r}
for (i in 1:11) {
  hist(ewb[,name],
       main = paste(colnames(ewb)[i]),
       xlab = "") 
}
```

Perfect! Now I have code that will generate histograms for every variable in a dataset. It may not look like it, but finding the right code for this took me a surprisingly long time.

Next, let's try to implement ggplot2 instead of just using base R. We'll explore this in the context of 2X2 interaction bar plots.

```{r}
dodge <- position_dodge(width=0.9)
#limits <- aes(ymax = mean + (se), ymin=mean - (se))
for (i in 1:length(names)) {
print(ggplot(ewb, aes(x = MEANDEP, y = mean(MEANPFR), fill = ACMPLM36))+
  geom_bar(stat='identity', position=dodge)+
  #geom_errorbar(limits, position=dodge, width=0.25)+
  labs(y="Estimation of Hours Saved", x= "Gain/Save Frame",
       title = "Effect of Time Frame on Estimation of Hours Saved")+
  scale_fill_hue(name="Frame", 
                 breaks=c("event","time"),
                 labels=c("Event", "Time")) )
}
```

```{r}
set.seed(154)
D <- data.frame(
    x1 = runif(100),
    x2 = rnorm(100)
)

library(ggplot2)
plots <- list()
for(nm in names(D)) {
    plots[[nm]] <- ggplot(data=D) + geom_density(aes_string(x=nm))
}

print(plots[["x1"]])
print(plots[["x2"]])
# works
```

```{r}
set.seed(154)
D <- data.frame(
    x1 = runif(100),
    x2 = rnorm(100)
)

library(ggplot2)
plots <- list()
(for(nm in names(ewb)) {
    plots[[nm]] <- ggplot(data=ewb) + geom_density(aes_string(x=nm))
})

print(plots[["x1"]])
print(plots[["x2"]])
# does not work
```


```{r}
# lapply(names(ewb)[ncol(ewb)], function(x) {
#     ewb_data <- ewb[, c(x, 'MEANDEP')]
#     names(ewb_data)[1] <- 'Var'
# 
#     ggplot(ewb_data, aes(x=Var, fill=factor(Var))) +
#       geom_bar() + 
#       facet_grid(~MEANDEP) +
#       theme_bw()
#   })
```

```{r}
# plotHistFunc <- function(x, na.rm = TRUE, ...) {
#   nm <- names(x)
#   for (i in seq_along(nm)) {
# plots <-ggplot(x,aes_string(x = nm[i])) + geom_histogram(alpha = .5,fill = "dodgerblue")
# ggsave(plots,filename=paste("myplot",nm[i],".png",sep=""))
#   }
# }
#  
# plotHistFunc(df)
```

```{r}
dat <- read.table(text="Method  Metric  E0  E1  E2  E4
M1  Precision   0.9661017   0.9622642   1   0.9655172
M2  Precision   0.533   0.535   0.378   0.214
M1  Recall  0.9736842   0.9736842   0.9473684   0.9473684
M2  Recall  1   1   1   0.667",header=TRUE)

layout(matrix(c(1,2,5,3,4,5),nrow=2,byrow = TRUE))
#     [,1] [,2] [,3]
#[1,]    1    2    5
#[2,]    3    4    5
barcols <- c("red","blue")

sapply(3:6, 
  function(x) {
    bp <- barplot(matrix(dat[,x],nrow=2,byrow=TRUE),beside=TRUE,col=barcols)
    title(main=names(dat[x]))
    axis(1,at=colMeans(bp),c("M1","M2"),lwd=0,lwd.tick=1)
    abline(h=0)
  }
)
# works
```

```{r}
layout(matrix(c(1,2,5,3,4,5),nrow=2,byrow = TRUE))
sapply(3:6, 
  function(x) {
    bp <- barplot(matrix(ewb[,x],nrow=2,byrow=TRUE),beside=TRUE,col=barcols)
    title(main=names(ewb[x]))
    axis(1,at=colMeans(bp),c("M1","M2"),lwd=0,lwd.tick=1)
    abline(h=0)
  }
)
```

```{r}

for (i in 1 : 11) {
col.i <- ewb[i]
filename <- paste (col.i, ".jpg", sep="")
barplot(ewb[, i], xlab = "Language Skills", ylim = c(1,3), xpd = FALSE,
     axes=FALSE, cex.names=.8, col=c("darkblue","red",
    "darkgreen", "yellow"))
dev.off()
}
```



Now, we will move onto the last task: working with a nested dataframe.

```{r warning = FALSE}
library(broom)
library(gapminder)
```

First, we will nest the data by country and continent.

```{r}
nest <- gapminder %>% 
   group_by(continent, country) %>% 
   nest()
head(nest)
nest$data[[1]]
```

In the above code, we have rearranged the gapminder dataset so that each row corresponds to a unique country. Within each country specific row are several other rows at a lower level of analysis that correspond to the 12 or so lines of observations we have for that specific country. These 12 lines of data are actually stored as lists within the "data" column within the nest dataframe.

One issue with this nested dataset is the way the list columns are organized (poorly).  

```{r}
(fit <- lm(lifeExp ~ I(year - 1950), data = nest[[1, "data"]]))

le_vs_yr <- function(df) {
  lm(lifeExp ~ I(year - 1950), data = df)
}
le_vs_yr(nest[[1, "data"]])
```

The stat545 lesson on this topic provides us with a way to turn our one-line model into a function that can be used to automate analysis for each country in the dataset.

```{r}
(fits <- map(nest$data[1:2], le_vs_yr))
```

This code uses the map function from the purrr package. It's very similar to the lapply function in base R and is used for doing computations involving list columns. This code also is a mini-test for a function that we wil produce soon. Instead of testing a model for all 142 countries, we are testing a model for 2 of them.

```{r}
(nest <- nest %>% 
   mutate(reg = map(data, le_vs_yr)))
```

What this code does is make yet another column that is filled with regression models. We are unfortunately still dealing with list columns. Sometimes things have to get worse before they can get better.

```{r}
(nest <- nest %>% 
  mutate(tidy = map(reg, tidy)))
```

```{r}
(reg_output <- nest %>% 
   select(continent, country, tidy) %>% 
   unnest(tidy))
```

What we've done here with this code is really amazing to me. We have created a nested version of our original dataframe, ran regression models on each of the elements nested within the new dataframe, and then transformed the dataframe back into an unnested one, but with the regression outputs retained. I can see how this will be very useful in the future.

Next we can explore the output that we have generated.



<h4>Process</h4>
I had to do some online research into how for loops work.
Figuring out how to get the right titles onto the automated plots was tricky and took a lot of trial and error. Methods that I thought should have worked simply did not.
<a href=http://stat545.com/block024_group-nest-split-map.html> This page </a>was quite useful for the nesting task. Working through it gave me a much better understanding of how nesting works.

